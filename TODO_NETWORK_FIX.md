# üìã TODOs: Fix de Actualizaciones Redundantes de Redes

## üéØ Objetivo
Parchear autoswarm para leer las redes desde `Spec.TaskTemplate.Networks` (y/o cachear el √∫ltimo valor aplicado) para que deje de emitir actualizaciones redundantes.

---

## üìä Resumen de TODOs

| Fase | TODOs | Tiempo Estimado | Estado |
|------|-------|-----------------|--------|
| **An√°lisis** | 4 | 30 min | üî¥ Pendiente |
| **Dise√±o** | 3 | 20 min | üî¥ Pendiente |
| **Desarrollo** | 5 | 45 min | üî¥ Pendiente |
| **Testing** | 5 | 60 min | üî¥ Pendiente |
| **Documentaci√≥n** | 2 | 15 min | üî¥ Pendiente |
| **TOTAL** | **19 TODOs** | **~2.5 horas** | üî¥ 0% |

---

## üìù TODOs Detallados por Fase

### üîç FASE 1: AN√ÅLISIS (30 min)

#### ‚òê TODO analysis-1: Investigar ubicaciones de redes en Docker Swarm
**Descripci√≥n**: Verificar d√≥nde Docker almacena las redes (Spec.Networks vs Spec.TaskTemplate.Networks) despu√©s de crear/actualizar servicios

**Acciones**:
- [ ] Crear script de diagn√≥stico para inspeccionar estructura de Spec
- [ ] Crear servicio de prueba y capturar Spec antes/despu√©s de actualizaci√≥n
- [ ] Documentar diferencias observadas
- [ ] Verificar si el comportamiento es consistente

**Entregable**: Documento con findings sobre ubicaciones de Networks

---

#### ‚òê TODO analysis-2: Reproducir el problema
**Descripci√≥n**: Crear servicio, aplicar redes, verificar logs de reconciliaci√≥n para confirmar actualizaciones redundantes

**Acciones**:
- [ ] Configurar `AUTOSWARM_LOG_LEVEL=DEBUG`
- [ ] Crear servicio con red Traefik
- [ ] Observar 3-5 ciclos de reconciliaci√≥n
- [ ] Capturar logs que muestren actualizaciones repetitivas
- [ ] Contar n√∫mero de actualizaciones redundantes

**Entregable**: Logs que evidencian el problema + m√©tricas (ej: 5 actualizaciones en 5 min)

---

#### ‚òê TODO analysis-3: Revisar documentaci√≥n Docker API
**Descripci√≥n**: Entender el comportamiento esperado de Networks en diferentes ubicaciones del Spec

**Acciones**:
- [ ] Leer Docker API docs sobre Service Spec
- [ ] Buscar informaci√≥n sobre Networks en Spec vs TaskTemplate
- [ ] Verificar si comportamiento est√° documentado o es bug
- [ ] Consultar issues de docker-py en GitHub

**Entregable**: Resumen de hallazgos de la documentaci√≥n

---

#### ‚òê TODO analysis-4: Identificar puntos de lectura de redes
**Descripci√≥n**: Encontrar todos los lugares donde se leen current_networks en reconciler.py

**Acciones**:
- [ ] Buscar todas las referencias a `Networks` en el c√≥digo
- [ ] Identificar otras lecturas similares que puedan tener el mismo problema
- [ ] Verificar si docker_manager.py tiene lecturas similares

**Entregable**: Lista de ubicaciones en el c√≥digo que necesitan actualizaci√≥n

---

### üé® FASE 2: DISE√ëO (20 min)

#### ‚òê TODO design-1: Definir estrategia de lectura de redes
**Descripci√≥n**: Decidir si leer de ambas ubicaciones, prioridad de lectura, o implementar cache

**Acciones**:
- [ ] Evaluar Opci√≥n 1: Lectura dual (Spec.Networks + TaskTemplate.Networks)
- [ ] Evaluar Opci√≥n 2: Cache de √∫ltimo valor aplicado
- [ ] Evaluar Opci√≥n 3: H√≠brida (dual + cache)
- [ ] Documentar pros/contras de cada opci√≥n
- [ ] **DECISI√ìN**: Seleccionar estrategia a implementar

**Entregable**: Documento de decisi√≥n t√©cnica

---

#### ‚òê TODO design-2: Dise√±ar funci√≥n get_current_networks()
**Descripci√≥n**: Crear m√©todo que lea de Spec.Networks y/o Spec.TaskTemplate.Networks con fallback inteligente

**Acciones**:
- [ ] Definir firma de la funci√≥n
- [ ] Especificar par√°metros de entrada
- [ ] Definir valor de retorno
- [ ] Documentar l√≥gica de prioridad/fallback
- [ ] Crear pseudoc√≥digo

**Entregable**: Dise√±o detallado de la funci√≥n con pseudoc√≥digo

---

#### ‚òê TODO design-3: Evaluar necesidad de cache
**Descripci√≥n**: Determinar si cachear √∫ltimo valor aplicado mejora la soluci√≥n o si lectura dual es suficiente

**Acciones**:
- [ ] Analizar si lectura dual resuelve 100% del problema
- [ ] Evaluar overhead de implementar cache
- [ ] Considerar edge cases (restart del agente, etc.)
- [ ] **DECISI√ìN**: Implementar cache o no

**Entregable**: Decisi√≥n documentada sobre implementaci√≥n de cache

---

### üíª FASE 3: DESARROLLO (45 min)

#### ‚òê TODO dev-1: Implementar get_current_networks() en Reconciler
**Descripci√≥n**: M√©todo que lee redes de Spec.Networks, TaskTemplate.Networks, o ambos

**Ubicaci√≥n**: `src/reconciler.py` (nueva funci√≥n en clase Reconciler)

**C√≥digo esperado**:
```python
def get_current_networks(self, service_spec: Dict) -> List[Dict[str, str]]:
    """
    Obtiene las redes actuales del servicio desde m√∫ltiples ubicaciones.

    Docker Swarm puede almacenar redes en:
    - Spec.Networks (nivel de servicio)
    - Spec.TaskTemplate.Networks (nivel de tarea, donde Docker las mueve)

    Returns:
        Lista de configuraciones de red actuales
    """
    # Implementaci√≥n aqu√≠
```

**Entregable**: Funci√≥n implementada y funcionando

---

#### ‚òê TODO dev-2: Actualizar reconcile_application()
**Descripci√≥n**: Reemplazar l√≠nea 127 para usar get_current_networks() en lugar de lectura directa

**Ubicaci√≥n**: `src/reconciler.py`, l√≠nea ~127

**Cambio**:
```python
# ANTES:
current_networks = service_spec.get("Networks") or []

# DESPU√âS:
current_networks = self.get_current_networks(service_spec)
```

**Entregable**: C√≥digo actualizado en reconcile_application()

---

#### ‚òê TODO dev-3: Mejorar logging
**Descripci√≥n**: Agregar logs DEBUG que muestren d√≥nde se encontraron las redes actuales y por qu√© se considera necesaria actualizaci√≥n

**Ubicaci√≥n**: `src/reconciler.py`, funci√≥n get_current_networks() y reconcile_application()

**Logs a agregar**:
```python
LOGGER.debug(
    "Service '%s' networks - Spec: %s, TaskTemplate: %s, Using: %s",
    service_name, spec_nets, task_nets, current_networks
)

LOGGER.debug(
    "Service '%s' network comparison - Current: %s, Desired: %s, Needs update: %s",
    service.name, current_networks, desired_networks, needs_network_update
)
```

**Entregable**: Logging mejorado para debugging

---

#### ‚òê TODO dev-4: (Opcional) Implementar cache de redes aplicadas
**Descripci√≥n**: Si se decide por cache, implementar diccionario {service_name: networks} con timestamp

**Condici√≥n**: Solo si design-3 decide implementar cache

**Ubicaci√≥n**: `src/reconciler.py`, clase Reconciler

**Estructura**:
```python
class Reconciler:
    def __init__(self, ...):
        # ... existente ...
        self._applied_networks_cache: Dict[str, List[Dict]] = {}
        self._cache_timestamps: Dict[str, float] = {}
        self._cache_ttl = 300  # 5 minutos
```

**Entregable**: Cache implementado (si aplicable)

---

#### ‚òê TODO dev-5: Agregar validaci√≥n de normalizaci√≥n
**Descripci√≥n**: Asegurar que ambas representaciones de redes se normalicen al mismo formato antes de comparar

**Ubicaci√≥n**: `src/reconciler.py`, funci√≥n service_networks_match()

**Acciones**:
- [ ] Verificar que formato de redes sea consistente
- [ ] Normalizar claves (may√∫sculas/min√∫sculas)
- [ ] Manejar orden de redes (si es relevante)
- [ ] Considerar aliases opcionales

**Entregable**: Comparaci√≥n de redes robusta y normalizada

---

### üß™ FASE 4: TESTING (60 min)

#### ‚òê TODO test-1: Crear test unitario para get_current_networks()
**Descripci√≥n**: Probar lectura desde Spec.Networks, TaskTemplate.Networks, y escenarios de fallback

**Ubicaci√≥n**: Crear `tests/test_reconciler_networks.py`

**Casos de prueba**:
```python
def test_get_current_networks_from_spec():
    """Redes solo en Spec.Networks"""

def test_get_current_networks_from_task_template():
    """Redes solo en TaskTemplate.Networks"""

def test_get_current_networks_both_locations():
    """Redes en ambos lugares - debe priorizar TaskTemplate"""

def test_get_current_networks_empty():
    """Sin redes en ninguna ubicaci√≥n"""
```

**Entregable**: Tests unitarios con 100% coverage de la funci√≥n

---

#### ‚òê TODO test-2: Test de integraci√≥n
**Descripci√≥n**: Crear servicio, reconciliar, verificar que no genere segunda actualizaci√≥n redundante

**Ubicaci√≥n**: `tests/integration/test_network_reconciliation.py`

**Flujo**:
```python
def test_no_redundant_network_updates():
    # 1. Crear servicio con red Traefik
    # 2. Primera reconciliaci√≥n (debe actualizar si necesario)
    # 3. Capturar n√∫mero de actualizaciones
    # 4. Segunda reconciliaci√≥n (NO debe actualizar)
    # 5. Tercera reconciliaci√≥n (NO debe actualizar)
    # 6. Assert: solo 1 actualizaci√≥n en total
```

**Entregable**: Test de integraci√≥n que valida el fix

---

#### ‚òê TODO test-3: Verificar logs
**Descripci√≥n**: Confirmar que logs DEBUG muestran correctamente detecci√≥n de redes y decisiones de actualizaci√≥n

**Acciones**:
- [ ] Ejecutar con `AUTOSWARM_LOG_LEVEL=DEBUG`
- [ ] Crear servicio y observar logs
- [ ] Verificar que muestra d√≥nde encontr√≥ las redes
- [ ] Verificar que explica decisi√≥n de update/no-update
- [ ] Confirmar claridad de mensajes

**Entregable**: Logs verificados y validados

---

#### ‚òê TODO test-4: Test con m√∫ltiples redes
**Descripci√≥n**: Verificar comportamiento con servicios que tienen m√∫ltiples redes overlay incluyendo Traefik

**Escenario**:
```python
def test_multiple_networks():
    # Servicio con:
    # - Red Traefik
    # - Red de aplicaci√≥n custom
    # - Red de base de datos
    # Verificar detecci√≥n correcta de todas
```

**Entregable**: Test con m√∫ltiples redes funcionando

---

#### ‚òê TODO test-5: Test de regresi√≥n
**Descripci√≥n**: Ejecutar suite completa para asegurar que el parche no rompe funcionalidad existente

**Acciones**:
- [ ] Ejecutar todos los tests existentes
- [ ] Ejecutar `python verify_refactor.py`
- [ ] Verificar que no hay regresiones
- [ ] Validar m√©tricas de performance

**Entregable**: Suite de tests pasando al 100%

---

### üìö FASE 5: DOCUMENTACI√ìN (15 min)

#### ‚òê TODO doc-1: Documentar comportamiento de Docker Swarm
**Descripci√≥n**: Agregar comentarios explicando por qu√© se leen redes de m√∫ltiples ubicaciones

**Ubicaci√≥n**: `src/reconciler.py`, funci√≥n get_current_networks()

**Contenido del comentario**:
```python
"""
Obtiene las redes actuales del servicio desde m√∫ltiples ubicaciones.

CONTEXTO:
Docker Swarm tiene un comportamiento donde las redes pueden estar en
diferentes ubicaciones del Spec dependiendo del momento:

1. Al crear/actualizar: Las redes se especifican en Spec.Networks
2. Despu√©s de aplicar: Docker puede mover las redes a Spec.TaskTemplate.Networks

Si solo leemos de Spec.Networks, podemos no encontrar redes que ya est√°n
aplicadas, causando actualizaciones redundantes.

SOLUCI√ìN:
Esta funci√≥n lee de ambas ubicaciones y prioriza TaskTemplate.Networks
cuando est√° disponible, ya que representa el estado efectivo del servicio.

Ver: NETWORK_RECONCILIATION_FIX.md para m√°s detalles.
"""
```

**Entregable**: C√≥digo bien documentado

---

#### ‚òê TODO doc-2: Actualizar ARCHITECTURE.md
**Descripci√≥n**: Documentar la soluci√≥n al problema de actualizaciones redundantes

**Ubicaci√≥n**: `ARCHITECTURE.md`

**Secci√≥n a agregar**:
```markdown
### Fix: Reconciliaci√≥n de Redes

**Problema**: Actualizaciones redundantes debido a lectura incorrecta de redes.

**Soluci√≥n**: Lectura dual de `Spec.Networks` y `Spec.TaskTemplate.Networks`.

**Detalles**: Ver `NETWORK_RECONCILIATION_FIX.md`
```

**Entregable**: ARCHITECTURE.md actualizado

---

## üéØ Criterios de Aceptaci√≥n

Para considerar este trabajo COMPLETO, se deben cumplir:

- [x] ‚úÖ Todos los 19 TODOs completados
- [ ] ‚úÖ Tests unitarios pasando (coverage > 90%)
- [ ] ‚úÖ Tests de integraci√≥n pasando
- [ ] ‚úÖ Logs muestran 0 actualizaciones redundantes en prueba de 5 ciclos
- [ ] ‚úÖ Documentaci√≥n actualizada y clara
- [ ] ‚úÖ Code review aprobado
- [ ] ‚úÖ Deploy exitoso sin regresiones

---

## üìà Progreso

```
Progreso: [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% (0/19 completados)

Estado por fase:
  An√°lisis:       [‚ñë‚ñë‚ñë‚ñë] 0/4
  Dise√±o:         [‚ñë‚ñë‚ñë] 0/3
  Desarrollo:     [‚ñë‚ñë‚ñë‚ñë‚ñë] 0/5
  Testing:        [‚ñë‚ñë‚ñë‚ñë‚ñë] 0/5
  Documentaci√≥n:  [‚ñë‚ñë] 0/2
```

---

## üöÄ Pr√≥ximos Pasos

1. **Iniciar analysis-1**: Crear script de diagn√≥stico
2. Ejecutar an√°lisis completo (30 min)
3. Proceder a dise√±o
4. Implementar soluci√≥n
5. Validar con tests
6. Documentar y desplegar

---

**Creado**: 2025-10-22
**Estimado**: 2.5 horas
**Prioridad**: Alta
**Asignado**: Equipo Autoswarm

